import dayjs from 'dayjs'

import AbstractScraper from './AbstractScraper'
import models from '../../models'
import {
  runAsyncSequence,
  runSequence,
} from '../../utils'
import {
  filterPreviouslyScrapedStatements,
  getUniqueCanonicalUrls,
} from '../../utils/scraper'

const { StatementLog } = models

class AbstractStatementScraper extends AbstractScraper {
  /**
   * The source is the specific context in which the statement appeared, as opposed to the platform
   * it was delivered via or the speaker who delivered it. For example, on TV, this would be a show
   * title; on social media, it would be the username of the poster.
   *
   * OVERRIDE WHEN EXTENDING
   *
   * @param {String} statement The scraped statement, which may be needed
   * @return {String}          The source for the statement
   */
  // (this is an abstract method and we need to define its footprint.)
  // eslint-disable-next-line no-unused-vars
  getStatementSource = (statement) => {
    throw new Error('You implemented a statement scraper but forgot to define the getStatementSource.')
  }

  /**
   * The canonical URL is the URL the user would consult to view the statement in context. It will
   * sometimes differ from the scrape URL, such as when using an API to access the statements.
   *
   * OVERRIDE WHEN EXTENDING
   *
   * @param {String} statement The scraped statement, which may be needed
   * @return {String}          The canonical URL for the statement
   */
  // (this is an abstract method and we need to define its footprint.)
  // eslint-disable-next-line no-unused-vars
  getStatementCanonicalUrl = (statement) => {
    throw new Error('You implemented a statement scraper but forgot to define the getStatementCanonicalUrl.')
  }

  /**
   * Statement scrapers are designed to extract statements from the scraped page.
   *
   * Each statement scraper that extends AbstractStatementScraper needs to implement
   * its own statementScrapeHandler method.
   *
   * OVERRIDE WHEN EXTENDING
   *
   * @param {String} responseString The HTML or JSON that came from the HTTP request
   * @return {Object[]}             The list of statements that were scraped
   */
  // (this is an abstract method and we need to define its footprint.)
  // eslint-disable-next-line no-unused-vars
  statementScrapeHandler = (responseString) => {
    throw new Error('You implemented a statement scraper but forgot to define the statementScrapeHandler.')
  }

  /**
   * Create an array of statement log value objects from a list of urls.
   * @param  {String[]} canonicalUrls The urls we want to create logs for
   * @return {Object[]}               The value objects for the statement logs
   */
  generateStatementLogValues = canonicalUrls => canonicalUrls.map(canonicalUrl => ({
    canonicalUrl,
    scraperName: this.getScraperName(),
  }))

  /**
   * Generates and saves a statement log entry for each distinct canonical url.
   * This is used to keep track of which statements have been seen by the system
   * (since not all statements end up being claims).
   *
   * @param  {Object[]} statements The array of statements to log
   * @return {Promise<StatementLog[]>} The saved initial statement log entries
   */
  createStatementLogs = async (statements) => {
    const sequence = [
      filterPreviouslyScrapedStatements,
      getUniqueCanonicalUrls,
      this.generateStatementLogValues,
    ]
    const statementLogValues = runSequence(sequence, statements)
    return StatementLog.bulkCreate(statementLogValues)
  }

  /**
   * Statements share common properties that are generated by predictable methods. Here we generate
   * and apply all these additional properties.
   *
   * @param {Object[]} statements The statements that have been scraped
   * @return {Object[]}           Those same statements with additional schema properties added
   */
  addSchemaPropertiesToStatements = (statements) => {
    const timestamp = dayjs().format()
    return statements.map(statement => ({
      ...statement,
      scraperName: this.getScraperName(),
      canonicalUrl: statement.canonicalUrl || this.getStatementCanonicalUrl(statement),
      source: statement.source || this.getStatementSource(statement),
      claimedAt: statement.claimedAt || timestamp,
    }))
  }

  /**
   * Statements have some properties that are not part of their schema but are
   * important for pipeline logic.  This decorates the scrapes with that information
   *
   * @param {Object[]} statements The statements that have been scraped
   * @return {Promise<Object[]>}  Those same statements with additional meta properties added
   */
  addMetaPropertiesToStatements = async statements => Promise.all(
    statements.map(async statement => ({
      ...statement,
      wasPreviouslyScraped: await StatementLog
        .getMostRecentStatementLogByStatement(statement) !== null,
    })),
  )

  scrapeHandler = async (responseString) => {
    const decorationSequence = [
      this.addSchemaPropertiesToStatements,
      this.addMetaPropertiesToStatements,
    ]
    const statements = this.statementScrapeHandler(responseString)
    const decoratedStatements = await runAsyncSequence(decorationSequence, statements)
    this.createStatementLogs(decoratedStatements)
    return decoratedStatements
  }
}

export default AbstractStatementScraper
